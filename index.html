<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ToF シリアルビューア（相対時間軸 & 任意Y軸）</title>

  <!-- Chart.js（v4固定 / 正しいscriptタグ） -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

  <!-- favicon（SVGをdata URLで埋め込み→404回避） -->
  <link rel="icon" type="image/svg+xml"
        href='data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><rect x="6" y="12" width="52" height="40" rx="8" fill="%231f77b4"/><path d="M14 24h36M14 32h24M14 40h16" stroke="%23fff" stroke-width="3"/></svg>'>

  <style>
    :root { color-scheme: light dark; }
    html, body { height: 100%; }
    body {
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", sans-serif;
      margin: 24px;
    }
    h1 { font-size: 1.25rem; margin-bottom: 0.5rem; }
    .row { display: flex; flex-wrap: wrap; gap: 12px; align-items: center; margin-bottom: 12px; }
    .row label { font-size: 0.9rem; }
    button { padding: 8px 14px; font-size: 0.95rem; }
    input[type="number"] { padding: 6px; font-size: 0.95rem; }
    .stats {
      display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 8px; margin-top: 10px;
    }
    .card { border: 1px solid #9993; border-radius: 8px; padding: 10px; }
    .val { font-size: 1.3rem; font-weight: 600; }
    #log {
      height: 160px; overflow: auto; white-space: pre;
      background: #0000000a; padding: 8px; border-radius: 8px; border: 1px solid #9993;
    }
    #chart { max-height: 380px; }
    .ok { color: #1a7f37; }
    .warn { color: #b44; }
    .muted { opacity: 0.7; }
    .section-title { margin-top: 16px; margin-bottom: 6px; }
    .badge { font-size: .85rem; padding: 2px 6px; border-radius: 8px; border: 1px solid #9993; }
  </style>
</head>
<body>
  <h1>ToF シリアルビューア（相対時間軸 & 任意Y軸） <span id="supportBadge" class="badge"></span></h1>

  <!-- 操作パネル -->
  <div class="row" aria-label="操作パネル">
    <button id="connectBtn">接続</button>
    <button id="disconnectBtn" disabled>切断</button>

    <label>ボーレート:
      <select id="baud" aria-label="ボーレート">
        <option value="115200" selected>115200</option>
        <option value="57600">57600</option>
        <option value="38400">38400</option>
        <option value="9600">9600</option>
      </select>
    </label>

    <label><input type="checkbox" id="autoScroll" checked /> ログ自動スクロール</label>
    <button id="saveCsvBtn" disabled>CSV保存</button>
    <button id="clearBtn">表示クリア</button>
  </div>

  <!-- 軸の設定 -->
  <h2 class="section-title">軸の設定</h2>
  <div class="row" style="gap:16px; align-items:flex-end;" aria-label="軸の設定">
    <div>
      <div class="muted">横軸：表示時間幅（相対・秒）</div>
      <label>ウィンドウ幅[s]:
        <input id="timeWindowSec" type="number" min="1" step="1" value="10" style="width:120px" />
      </label>
    </div>
    <div>
      <div class="muted">縦軸：距離[mm]（空欄＝自動）</div>
      <label>min:
        <input id="yMin" type="number" placeholder="自動" style="width:110px" />
      </label>
      <label>max:
        <input id="yMax" type="number" placeholder="自動" style="width:110px" />
      </label>
    </div>
    <div>
      <button id="applyAxisBtn">適用</button>
      <button id="resetAxisBtn">リセット（自動）</button>
    </div>
  </div>

  <!-- 統計 -->
  <div class="stats" aria-label="統計情報">
    <div class="card"><div class="muted">接続状態</div><div id="status" class="val">未接続</div></div>
    <div class="card"><div class="muted">ポート情報</div><div id="portInfo" class="val">-</div></div>
    <div class="card"><div class="muted">最新距離 [mm]</div><div id="latestVal" class="val">-</div></div>
    <div class="card"><div class="muted">最新時刻 [ms]</div><div id="latestTime" class="val">-</div></div>
    <div class="card"><div class="muted">TIMEOUT 回数</div><div id="timeoutCount" class="val">0</div></div>
    <div class="card"><div class="muted">サンプル数</div><div id="sampleCount" class="val">0</div></div>
    <div class="card"><div class="muted">推定サンプリング周期</div><div id="samplePeriod" class="val">-</div></div>
  </div>

  <h2 class="section-title">グラフ（横軸=最新からの相対時間[s], 縦軸=距離[mm]）</h2>
  <canvas id="chart" aria-label="距離グラフ" role="img"></canvas>

  <h2 class="section-title">受信ログ</h2>
  <div id="log" aria-live="polite"></div>

  <script>
    (() => {
      'use strict';

      // ---- Web Serial 対応表示 ----
      const supportBadge = document.getElementById('supportBadge');
      if ('serial' in navigator) {
        supportBadge.textContent = 'Web Serial 対応ブラウザ ✓';
        supportBadge.style.borderColor = '#1a7f37';
        supportBadge.style.color = '#1a7f37';
      } else {
        supportBadge.textContent = 'このブラウザはWeb Serial非対応';
        supportBadge.style.borderColor = '#b44';
        supportBadge.style.color = '#b44';
      }

      // ---- DOM要素 ----
      const els = {
        connectBtn: document.getElementById('connectBtn'),
        disconnectBtn: document.getElementById('disconnectBtn'),
        baudSel: document.getElementById('baud'),
        autoScrollChk: document.getElementById('autoScroll'),
        saveCsvBtn: document.getElementById('saveCsvBtn'),
        clearBtn: document.getElementById('clearBtn'),
        timeWindowSecInput: document.getElementById('timeWindowSec'),
        yMinInput: document.getElementById('yMin'),
        yMaxInput: document.getElementById('yMax'),
        applyAxisBtn: document.getElementById('applyAxisBtn'),
        resetAxisBtn: document.getElementById('resetAxisBtn'),
        statusEl: document.getElementById('status'),
        portInfoEl: document.getElementById('portInfo'),
        latestValEl: document.getElementById('latestVal'),
        latestTimeEl: document.getElementById('latestTime'),
        timeoutCountEl: document.getElementById('timeoutCount'),
        sampleCountEl: document.getElementById('sampleCount'),
        samplePeriodEl: document.getElementById('samplePeriod'),
        logEl: document.getElementById('log'),
        chartCanvas: document.getElementById('chart'),
      };

      // ---- 状態 ----
      const state = {
        port: null,
        reader: null,
        sampleCount: 0,
        timeoutCount: 0,
        prevMillisForPeriod: null,
        timesMs: [],
        dists: [],
        lastMillis: null,
        windowMs: 10_000, // 10秒
        receiveCsv: [],
      };

      // ---- ログ（改行を頑健化して表示）----
      function appendLog(line) {
        // 文字としての "\r\n" / "\r" / "\n" を実際の改行に正規化
        const replAll = (s, from, to) => (s.replaceAll ? s.replaceAll(from, to) : s.split(from).join(to));
        let normalized = line;
        normalized = replAll(normalized, '\\r\\n', '\n');
        normalized = replAll(normalized, '\\r',   '\n');
        normalized = replAll(normalized, '\\n',   '\n');

        const maxLen = 200000;
        els.logEl.textContent += normalized + '\n';
        if (els.logEl.textContent.length > maxLen) {
          els.logEl.textContent = els.logEl.textContent.slice(-maxLen);
        }
        if (els.autoScrollChk.checked) els.logEl.scrollTop = els.logEl.scrollHeight;
      }

      // ---- 1行のパース ----
      function parseLine(line) {
        const commaIdx = line.indexOf(',');
        if (commaIdx < 0) return null;

        const msStr = line.slice(0, commaIdx).trim();
        const rest = line.slice(commaIdx + 1).trim();

        let isTimeout = false;
        let distStr = rest;
        const timeoutIdx = rest.indexOf('TIMEOUT');
        if (timeoutIdx >= 0) {
          isTimeout = true;
          distStr = rest.slice(0, timeoutIdx).trim();
        }

        const millis = Number.parseInt(msStr, 10);
        const distance = Number.parseInt(distStr, 10);
        if (!Number.isFinite(millis) || !Number.isFinite(distance)) return null;

        return { millis, distance, isTimeout };
      }

      // ---- グラフ ----
      const chart = new Chart(els.chartCanvas, {
        type: 'line',
        data: {
          datasets: [{
            label: '距離 [mm]',
            data: [],
            borderColor: '#1f77b4',
            backgroundColor: 'rgba(31,119,180,0.1)',
            pointRadius: 0,
            tension: 0.15,
          }]
        },
        options: {
          animation: false,
          responsive: true,
          maintainAspectRatio: false,
          parsing: false, // {x,y}をそのまま使用
          scales: {
            x: {
              type: 'linear',
              title: { display: true, text: '相対時間 [s]' },
              min: -state.windowMs,
              max: 0,
              ticks: { callback: (v) => (v/1000).toFixed(1) },
            },
            y: {
              title: { display: true, text: '距離 [mm]' },
            }
          },
          plugins: { legend: { display: true } }
        }
      });

      function pushData(millis, distance) {
        state.timesMs.push(millis);
        state.dists.push(distance);
        state.lastMillis = millis;

        // 古いデータを間引き（1.5倍ぶんは残して負荷を抑える）
        const cutoff = millis - state.windowMs * 1.5;
        while (state.timesMs.length && state.timesMs[0] < cutoff) {
          state.timesMs.shift();
          state.dists.shift();
        }
      }

      function refreshChart() {
        if (state.lastMillis == null) return;
        const data = [];
        for (let i = 0; i < state.timesMs.length; i++) {
          const rel = state.timesMs[i] - state.lastMillis; // 0（最新）〜 負（過去）
          if (rel >= -state.windowMs) data.push({ x: rel, y: state.dists[i] });
        }
        chart.data.datasets[0].data = data;
        chart.options.scales.x.min = -state.windowMs;
        chart.options.scales.x.max = 0;
        chart.update('none');
      }

      function updateStats({ millis, distance, isTimeout }) {
        els.latestValEl.textContent = (distance ?? "-");
        els.latestTimeEl.textContent = (millis ?? "-");

        state.sampleCount++;
        els.sampleCountEl.textContent = state.sampleCount.toString();

        if (isTimeout) {
          state.timeoutCount++;
          els.timeoutCountEl.textContent = state.timeoutCount.toString();
        }

        if (state.prevMillisForPeriod != null && Number.isFinite(millis)) {
          const period = millis - state.prevMillisForPeriod;
          if (period > 0 && period < 100000) {
            els.samplePeriodEl.textContent = `${period} ms (${(1000/period).toFixed(2)} Hz)`;
          }
        }
        state.prevMillisForPeriod = millis;

        els.statusEl.className = isTimeout ? 'warn' : 'ok';
        els.statusEl.textContent = state.port ? '接続中' : '未接続';
      }

      // ---- 軸設定 ----
      function applyAxis() {
        const t = Number(els.timeWindowSecInput.value);
        if (Number.isFinite(t) && t > 0) {
          state.windowMs = Math.floor(t * 1000);
        } else {
          alert('時間ウィンドウは正の数値（秒）を入力してください');
          return;
        }
        const yminStr = els.yMinInput.value.trim();
        const ymaxStr = els.yMaxInput.value.trim();
        const ymin = yminStr === '' ? undefined : Number(yminStr);
        const ymax = ymaxStr === '' ? undefined : Number(ymaxStr);
        if (ymin !== undefined && ymax !== undefined && ymin >= ymax) {
          alert('縦軸の min は max より小さくしてください');
          return;
        }
        chart.options.scales.x.min = -state.windowMs;
        chart.options.scales.x.max = 0;
        chart.options.scales.y.min = ymin;
        chart.options.scales.y.max = ymax;
        refreshChart();
      }

      function resetAxis() {
        els.timeWindowSecInput.value = '10';
        els.yMinInput.value = '';
        els.yMaxInput.value = '';
        state.windowMs = 10_000;
        chart.options.scales.x.min = -state.windowMs;
        chart.options.scales.x.max = 0;
        chart.options.scales.y.min = undefined;
        chart.options.scales.y.max = undefined;
        refreshChart();
      }

      // ---- 受信（改行の頑健化トランスフォーマ）----
      class LineBreakTransformer {
        constructor() { this.container = ""; }
        transform(chunk, controller) {
          // 文字としての "\r\n" / "\r" / "\n" を実際の改行に正規化
          const replAll = (s, from, to) => (s.replaceAll ? s.replaceAll(from, to) : s.split(from).join(to));
          let text = chunk;
          text = replAll(text, '\\r\\n', '\n');
          text = replAll(text, '\\r',   '\n');
          text = replAll(text, '\\n',   '\n');

          // 実際の改行コード（\r\n / \n / \r）で分割 ※簡潔な安全パターン
          this.container += text;
          const lines = this.container.split(/\r\n|\n|\r/);
          this.container = lines.pop();
          for (const line of lines) controller.enqueue(line);
        }
        flush(controller) {
          if (this.container) controller.enqueue(this.container);
        }
      }

      async function readLoop() {
        if (!state.port?.readable) return;

        const textDecoder = new TextDecoderStream();
        const lineStream = state.port.readable
          .pipeThrough(textDecoder)
          .pipeThrough(new TransformStream({
            start() { this.lbt = new LineBreakTransformer(); },
            transform(chunk, controller) { this.lbt.transform(chunk, controller); },
            flush(controller) { this.lbt.flush(controller); }
          }));

        const reader = lineStream.getReader();
        state.reader = reader;

        try {
          while (true) {
            const { value, done } = await reader.read();
            if (done) break;
            if (typeof value !== 'string') continue;

            appendLog(value);

            const parsed = parseLine(value);
            if (!parsed) continue;

            const { millis, distance, isTimeout } = parsed;
            state.receiveCsv.push([millis, distance, isTimeout ? 1 : 0]);
            pushData(millis, distance);
            updateStats({ millis, distance, isTimeout });
            refreshChart();
          }
        } catch (err) {
          console.error(err);
          appendLog(`[エラー] ${String(err)}`);
        } finally {
          try { await reader.releaseLock(); } catch {}
          state.reader = null;
        }
      }

      // ---- 接続/切断/保存/表示クリア ----
      async function connect() {
        if (!('serial' in navigator)) {
          alert('このブラウザは Web Serial に対応していません。Chrome または Edge の最新版をお使いください。');
          return;
        }
        try {
          const p = await navigator.serial.requestPort();
          const baudRate = Number.parseInt(els.baudSel.value, 10);
          await p.open({ baudRate, dataBits: 8, stopBits: 1, parity: 'none', flowControl: 'none' });

          state.port = p;
          els.connectBtn.disabled = true;
          els.disconnectBtn.disabled = false;
          els.saveCsvBtn.disabled = false;

          // ポート情報
          try {
            const info = state.port.getInfo?.();
            if (info && (info.usbVendorId || info.usbProductId)) {
              const v = info.usbVendorId ? '0x' + info.usbVendorId.toString(16) : '?';
              const d = info.usbProductId ? '0x' + info.usbProductId.toString(16) : '?';
              els.portInfoEl.textContent = `VID ${v} / PID ${d}`;
            } else {
              els.portInfoEl.textContent = 'USB CDC / 不明';
            }
          } catch { els.portInfoEl.textContent = '-'; }

          els.statusEl.textContent = '接続中';
          els.statusEl.className = 'ok';

          // 初期化
          state.timeoutCount = 0;
          state.sampleCount = 0;
          state.prevMillisForPeriod = null;
          state.lastMillis = null;
          state.timesMs.length = 0;
          state.dists.length = 0;
          state.receiveCsv = [["millis","distance","timeout"]];
          chart.data.datasets[0].data = [];
          chart.update();

          await readLoop();

        } catch (err) {
          console.error(err);
          alert('接続に失敗しました: ' + String(err));
          await disconnect(true);
        }
      }

      async function disconnect(silent = false) {
        els.disconnectBtn.disabled = true;
        try {
          if (state.reader) {
            try { await state.reader.cancel(); } catch {}
            try { await state.reader.releaseLock(); } catch {}
            state.reader = null;
          }
          if (state.port?.readable) { try { await state.port.readable.cancel(); } catch {} }
          if (state.port?.writable) { try { await state.port.writable.abort?.(); } catch {} }
          if (state.port) { try { await state.port.close(); } catch {} }
        } finally {
          state.port = null;
          els.connectBtn.disabled = false;
          els.saveCsvBtn.disabled = state.receiveCsv.length <= 1;
          els.statusEl.textContent = '未接続';
          els.statusEl.className = '';
          if (!silent) appendLog('[切断]');
        }
      }

      function saveCsv() {
        if (state.receiveCsv.length <= 1) {
          alert('保存するデータがありません。');
          return;
        }
        const lines = state.receiveCsv.map(row => row.join(',')).join('\n');
        const blob = new Blob([lines], { type: 'text/csv;charset=utf-8' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        const dateStr = new Date().toISOString().replace(/[:.]/g, '-');
        a.href = url; a.download = `tof_serial_${dateStr}.csv`; a.click();
        URL.revokeObjectURL(url);
      }

      function clearView() {
        els.logEl.textContent = '';
        els.latestValEl.textContent = '-';
        els.latestTimeEl.textContent = '-';
        state.timeoutCount = 0; els.timeoutCountEl.textContent = '0';
        state.sampleCount = 0; els.sampleCountEl.textContent = '0';
        els.samplePeriodEl.textContent = '-';
        state.timesMs.length = 0; state.dists.length = 0; state.lastMillis = null; state.prevMillisForPeriod = null;
        chart.data.datasets[0].data = []; chart.update();
      }

      // ---- イベント ----
      navigator.serial?.addEventListener('connect', () => appendLog('[デバイスが接続されました]'));
      navigator.serial?.addEventListener('disconnect', () => appendLog('[デバイスが取り外されました]'));
      els.connectBtn.addEventListener('click', connect);
      els.disconnectBtn.addEventListener('click', () => disconnect(false));
      els.saveCsvBtn.addEventListener('click', saveCsv);
      els.clearBtn.addEventListener('click', clearView);
      els.applyAxisBtn.addEventListener('click', applyAxis);
      els.resetAxisBtn.addEventListener('click', resetAxis);

      // 初期適用
      applyAxis();
    })();
  </script>
</body>
</html>
