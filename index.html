<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>ToF シリアルビューア（相対時間軸 & 任意Y軸）</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Chart.js (v4系) -->
  https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    :root { color-scheme: light dark; }
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", sans-serif; margin: 24px; }
    h1 { font-size: 1.2rem; margin-bottom: 0.5rem; }
    .row { display: flex; flex-wrap: wrap; gap: 12px; align-items: center; margin-bottom: 12px; }
    .row label { font-size: 0.9rem; }
    button { padding: 8px 14px; font-size: 0.95rem; }
    input[type="number"] { padding: 6px; font-size: 0.95rem; }
    .stats { display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 8px; margin-top: 10px; }
    .card { border: 1px solid #9993; border-radius: 8px; padding: 10px; }
    .val { font-size: 1.4rem; font-weight: 600; }
    #log { height: 160px; overflow: auto; white-space: pre; background: #0000000a; padding: 8px; border-radius: 8px; border: 1px solid #9993; }
    #chart { max-height: 380px; }
    .ok { color: #1a7f37; }
    .warn { color: #b44; }
    .muted { opacity: 0.7; }
    .section-title { margin-top: 16px; margin-bottom: 6px; }
  </style>
</head>
<body>
  <h1>ToF シリアルビューア（相対時間軸 & 任意Y軸）</h1>

  <!-- 操作パネル -->
  <div class="row">
    <button id="connectBtn">接続</button>
    <button id="disconnectBtn" disabled>切断</button>

    <label>ボーレート:
      <select id="baud">
        <option value="115200" selected>115200</option>
        <option value="57600">57600</option>
        <option value="38400">38400</option>
        <option value="9600">9600</option>
      </select>
    </label>

    <label><input type="checkbox" id="autoScroll" checked /> ログ自動スクロール</label>
    <button id="saveCsvBtn" disabled>CSV保存</button>
    <button id="clearBtn">表示クリア</button>
  </div>

  <!-- 軸の設定 -->
  <h2 class="section-title">軸の設定</h2>
  <div class="row" style="gap:16px; align-items:flex-end;">
    <div>
      <div class="muted">横軸：表示時間幅（相対時間・秒）</div>
      <label>ウィンドウ幅[s]:
        <input id="timeWindowSec" type="number" min="1" step="1" value="10" style="width:120px" />
      </label>
    </div>
    <div>
      <div class="muted">縦軸：距離[mm]（空欄＝自動）</div>
      <label>min:
        <input id="yMin" type="number" placeholder="自動" style="width:110px" />
      </label>
      <label>max:
        <input id="yMax" type="number" placeholder="自動" style="width:110px" />
      </label>
    </div>
    <div>
      <button id="applyAxisBtn">適用</button>
      <button id="resetAxisBtn">リセット（自動）</button>
    </div>
  </div>

  <!-- 統計 -->
  <div class="stats">
    <div class="card"><div class="muted">接続状態</div><div id="status" class="val">未接続</div></div>
    <div class="card"><div class="muted">ポート情報</div><div id="portInfo" class="val">-</div></div>
    <div class="card"><div class="muted">最新距離 [mm]</div><div id="latestVal" class="val">-</div></div>
    <div class="card"><div class="muted">最新時刻 [ms]</div><div id="latestTime" class="val">-</div></div>
    <div class="card"><div class="muted">TIMEOUT 回数</div><div id="timeoutCount" class="val">0</div></div>
    <div class="card"><div class="muted">サンプル数</div><div id="sampleCount" class="val">0</div></div>
    <div class="card"><div class="muted">推定サンプリング周期</div><div id="samplePeriod" class="val">-</div></div>
  </div>

  <h2 class="section-title">グラフ（横軸=最新からの相対時間[s], 縦軸=距離[mm]）</h2>
  <canvas id="chart"></canvas>

  <h2 class="section-title">受信ログ</h2>
  <div id="log"></div>

  <script>
    // ========== ユーティリティ（行単位に区切る） ==========
    class LineBreakTransformer {
      constructor() { this.container = ""; }
      transform(chunk, controller) {
        this.container += chunk;
        const lines = this.container.split(/\r?\n/);
        this.container = lines.pop();
        for (const line of lines) controller.enqueue(line);
      }
      flush(controller) {
        if (this.container) controller.enqueue(this.container);
      }
    }

    // ========== 要素取得 ==========
    const connectBtn = document.getElementById('connectBtn');
    const disconnectBtn = document.getElementById('disconnectBtn');
    const baudSel = document.getElementById('baud');
    const autoScrollChk = document.getElementById('autoScroll');
    const saveCsvBtn = document.getElementById('saveCsvBtn');
    const clearBtn = document.getElementById('clearBtn');

    const timeWindowSecInput = document.getElementById('timeWindowSec');
    const yMinInput = document.getElementById('yMin');
    const yMaxInput = document.getElementById('yMax');
    const applyAxisBtn = document.getElementById('applyAxisBtn');
    const resetAxisBtn = document.getElementById('resetAxisBtn');

    const statusEl = document.getElementById('status');
    const portInfoEl = document.getElementById('portInfo');
    const latestValEl = document.getElementById('latestVal');
    const latestTimeEl = document.getElementById('latestTime');
    const timeoutCountEl = document.getElementById('timeoutCount');
    const sampleCountEl = document.getElementById('sampleCount');
    const samplePeriodEl = document.getElementById('samplePeriod');
    const logEl = document.getElementById('log');

    // ========== 状態 ==========
    let port = null;
    let reader = null;
    let reading = false;

    let timeoutCount = 0;
    let sampleCount = 0;

    // 受信データ（絶対ミリ秒と距離）を保持
    const timesMs = [];   // 絶対時間（ESP32のmillis）
    const dists = [];     // 距離[mm]
    let lastMillis = null;

    // 表示ウィンドウ（相対時間の幅）
    let windowMs = 10_000; // 既定10秒

    // CSV 保存用
    let receiveCsv = []; // [["millis","distance","timeout"], ...]

    // ========== Chart.js 初期化 ==========
    const chartCtx = document.getElementById('chart');
    const chart = new Chart(chartCtx, {
      type: 'line',
      data: {
        // 相対時間表示のため、labelsは使わず datasets[0].data に {x,y} を入れる
        datasets: [{
          label: '距離 [mm]',
          data: [],
          borderColor: '#1f77b4',
          backgroundColor: 'rgba(31,119,180,0.1)',
          pointRadius: 0,
          tension: 0.15,
        }]
      },
      options: {
        animation: false,
        responsive: true,
        maintainAspectRatio: false,
        parsing: false,            // {x,y} をそのまま使う
        scales: {
          x: {
            type: 'linear',
            title: { display: true, text: '相対時間 [s]' },
            // 相対時間: 最新=0s, 過去=負の値
            min: -windowMs,  // ms（内部はms、表示はticks callbackで秒化）
            max: 0,
            ticks: {
              callback: (v) => (v/1000).toFixed(1), // 秒表示
            },
          },
          y: {
            title: { display: true, text: '距離 [mm]' },
            // min/max は applyAxis() でユーザー指定に応じて設定
          }
        },
        plugins: {
          legend: { display: true }
        }
      }
    });

    function appendLog(line) {
      logEl.textContent += line + "\n";
      if (logEl.textContent.length > 200000) {
        logEl.textContent = logEl.textContent.slice(-200000);
      }
      if (autoScrollChk.checked) logEl.scrollTop = logEl.scrollHeight;
    }

    function updateStats({ millis, distance, isTimeout }) {
      latestValEl.textContent = (distance ?? "-");
      latestTimeEl.textContent = (millis ?? "-");
      sampleCountEl.textContent = sampleCount.toString();
      timeoutCountEl.textContent = timeoutCount.toString();

      // サンプリング周期（受信ミリ秒の差分から推定）
      staticLastMillis = updateStats._lastMillis || null;
      if (staticLastMillis != null && millis != null) {
        const period = millis - staticLastMillis;
        if (period > 0 && period < 100000) {
          samplePeriodEl.textContent = `${period} ms (${(1000/period).toFixed(2)} Hz)`;
        }
      }
      updateStats._lastMillis = millis;

      statusEl.className = isTimeout ? 'warn' : 'ok';
      statusEl.textContent = port ? '接続中' : '未接続';
    }

    // データバッファに追加 & 古いデータの間引き（時間窓に応じて）
    function pushData(millis, distance) {
      timesMs.push(millis);
      dists.push(distance);

      // 最新の絶対時刻を保持
      lastMillis = millis;

      // 表示窓より古いデータを削除（最大で窓の1.5倍の余裕）
      const cutoff = millis - windowMs * 1.5;
      while (timesMs.length > 0 && timesMs[0] < cutoff) {
        timesMs.shift();
        dists.shift();
      }
    }

    // グラフのデータを再構成（絶対ms -> 相対msに変換）
    function refreshChart() {
      if (lastMillis == null) return;
      const data = [];
      for (let i = 0; i < timesMs.length; i++) {
        const rel = timesMs[i] - lastMillis; // 0（最新）〜 マイナス（過去）
        if (rel >= -windowMs) {
          data.push({ x: rel, y: dists[i] });
        }
      }
      chart.data.datasets[0].data = data;
      chart.options.scales.x.min = -windowMs;
      chart.options.scales.x.max = 0;
      chart.update('none');
    }

    function parseLine(line) {
      // "<millis>,<distance>" or "<millis>,<distance> TIMEOUT"
      const commaIdx = line.indexOf(',');
      if (commaIdx < 0) return null;

      const msStr = line.slice(0, commaIdx).trim();
      const rest = line.slice(commaIdx + 1).trim();

      let isTimeout = false;
      let distStr = rest;
      const timeoutIdx = rest.indexOf('TIMEOUT');
      if (timeoutIdx >= 0) {
        isTimeout = true;
        distStr = rest.slice(0, timeoutIdx).trim();
      }

      const millis = Number.parseInt(msStr, 10);
      const distance = Number.parseInt(distStr, 10);
      if (!Number.isFinite(millis) || !Number.isFinite(distance)) return null;

      return { millis, distance, isTimeout };
    }

    async function readLoop() {
      if (!port?.readable) return;

      const textDecoder = new TextDecoderStream();
      const lineStream = port.readable
        .pipeThrough(textDecoder)
        .pipeThrough(new TransformStream({
          start() { this.lbt = new LineBreakTransformer(); },
          transform(chunk, controller) { this.lbt.transform(chunk, controller); },
          flush(controller) { this.lbt.flush(controller); }
        }));

      reader = lineStream.getReader();
      reading = true;

      try {
        while (true) {
          const { value, done } = await reader.read();
          if (done) break;
          if (typeof value !== 'string') continue;

          appendLog(value);

          const parsed = parseLine(value);
          if (!parsed) continue;

          const { millis, distance, isTimeout } = parsed;
          sampleCount++;
          if (isTimeout) timeoutCount++;

          // CSV バッファにも保存
          receiveCsv.push([millis, distance, isTimeout ? 1 : 0]);

          // データ追記＆再描画
          pushData(millis, distance);
          updateStats({ millis, distance, isTimeout });
          refreshChart();
        }
      } catch (err) {
        console.error(err);
        appendLog(`[エラー] ${String(err)}`);
      } finally {
        reading = false;
        try { await reader.releaseLock(); } catch {}
      }
    }

    async function connect() {
      if (!('serial' in navigator)) {
        alert('このブラウザは Web Serial に対応していません。Chrome または Edge の最新版をお使いください。');
        return;
      }
      try {
        const p = await navigator.serial.requestPort(); // ユーザーが選択
        const baudRate = Number.parseInt(baudSel.value, 10);
        await p.open({ baudRate, dataBits: 8, stopBits: 1, parity: 'none', flowControl: 'none' });

        port = p;
        connectBtn.disabled = true;
        disconnectBtn.disabled = false;
        saveCsvBtn.disabled = false;

        // ポート情報
        let infoText = '-';
        try {
          const info = port.getInfo?.();
          if (info && (info.usbVendorId || info.usbProductId)) {
            const v = info.usbVendorId ? '0x' + info.usbVendorId.toString(16) : '?';
            const d = info.usbProductId ? '0x' + info.usbProductId.toString(16) : '?';
            infoText = `VID ${v} / PID ${d}`;
          } else {
            infoText = 'USB CDC / 不明';
          }
        } catch {}
        portInfoEl.textContent = infoText;

        statusEl.textContent = '接続中';
        statusEl.className = 'ok';

        // 受信状態を初期化
        timeoutCount = 0; sampleCount = 0; lastMillis = null;
        timesMs.length = 0; dists.length = 0;
        receiveCsv = [["millis","distance","timeout"]];
        chart.data.datasets[0].data = [];
        chart.update();

        await readLoop();

      } catch (err) {
        console.error(err);
        alert('接続に失敗しました: ' + String(err));
        await disconnect(true);
      }
    }

    async function disconnect(silent = false) {
      disconnectBtn.disabled = true;
      try {
        if (reader) {
          try { await reader.cancel(); } catch {}
          try { await reader.releaseLock(); } catch {}
        }
        if (port?.readable) {
          try { await port.readable.cancel(); } catch {}
        }
        if (port?.writable) {
          try { await port.writable.abort?.(); } catch {}
        }
        if (port) {
          try { await port.close(); } catch {}
        }
      } finally {
        port = null;
        reader = null;
        reading = false;
        connectBtn.disabled = false;
        saveCsvBtn.disabled = receiveCsv.length <= 1;
        statusEl.textContent = '未接続';
        statusEl.className = '';
        if (!silent) appendLog('[切断]');
      }
    }

    function saveCsv() {
      if (receiveCsv.length <= 1) {
        alert('保存するデータがありません。');
        return;
      }
      const lines = receiveCsv.map(row => row.join(',')).join('\n');
      const blob = new Blob([lines], { type: 'text/csv;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      const dateStr = new Date().toISOString().replace(/[:.]/g, '-');
      a.href = url;
      a.download = `tof_serial_${dateStr}.csv`;
      a.click();
      URL.revokeObjectURL(url);
    }

    function clearView() {
      logEl.textContent = '';
      latestValEl.textContent = '-';
      latestTimeEl.textContent = '-';
      timeoutCount = 0; timeoutCountEl.textContent = '0';
      sampleCount = 0; sampleCountEl.textContent = '0';
      samplePeriodEl.textContent = '-';

      timesMs.length = 0;
      dists.length = 0;
      lastMillis = null;

      chart.data.datasets[0].data = [];
      chart.update();
    }

    // 軸の適用／リセット
    function applyAxis() {
      // 時間窓（秒）→ ms
      const t = Number(timeWindowSecInput.value);
      if (Number.isFinite(t) && t > 0) {
        windowMs = Math.floor(t * 1000);
      } else {
        alert('時間ウィンドウは正の数値（秒）を入力してください');
        return;
      }

      // Y軸 min/max
      const yminStr = yMinInput.value.trim();
      const ymaxStr = yMaxInput.value.trim();
      const ymin = yminStr === '' ? undefined : Number(yminStr);
      const ymax = ymaxStr === '' ? undefined : Number(ymaxStr);

      if (ymin !== undefined && ymax !== undefined && ymin >= ymax) {
        alert('縦軸の min は max より小さくしてください');
        return;
      }

      chart.options.scales.x.min = -windowMs;
      chart.options.scales.x.max = 0;
      chart.options.scales.y.min = ymin;
      chart.options.scales.y.max = ymax;

      refreshChart();
    }

    function resetAxis() {
      timeWindowSecInput.value = '10';
      yMinInput.value = '';
      yMaxInput.value = '';

      windowMs = 10_000;
      chart.options.scales.x.min = -windowMs;
      chart.options.scales.x.max = 0;
      chart.options.scales.y.min = undefined;
      chart.options.scales.y.max = undefined;

      refreshChart();
    }

    // シリアルの自動イベント
    navigator.serial?.addEventListener('connect', (event) => {
      appendLog('[デバイスが接続されました]');
    });
    navigator.serial?.addEventListener('disconnect', async (event) => {
      appendLog('[デバイスが取り外されました]');
      await disconnect(true);
    });

    // イベントバインド
    connectBtn.addEventListener('click', connect);
    disconnectBtn.addEventListener('click', () => disconnect(false));
    saveCsvBtn.addEventListener('click', saveCsv);
    clearBtn.addEventListener('click', clearView);
    applyAxisBtn.addEventListener('click', applyAxis);
    resetAxisBtn.addEventListener('click', resetAxis);

    // 初期適用
    applyAxis();
  </script>
</body>
</html>
``
